#线性时间排序

> 于2016-03-30补充完成，之前拖延很久

###基于比较的排序时间下限

任何比较排序在最坏情况下都要使用 `nlgn`次比较来排序。

###计数排序(counting-sort)

计数排序假设输入是一系列的正整数（以及0），故最小值大于等于0，且最大值`k`满足 `k = O(n)`（即是`k <= Cn`的，当n大于某个阈值。其中C是一个常数），n是输入数据的数量。

这个要求对于普遍意义的排序是非常严格的，但是对于某些特定任务，也许是可以满足的。特别地，计数排序还可以用于基数排序的子过程，过可以处理更大范围的整数。在满足任务要求的情况下，计数排序有非常良好的性质，由于其不是基于比较的，故不受基于比较的排序时间下限`nlgn`的约束。

其是线性时间的。

且由于其反向处理，故是稳定的。

具体描述该算法：设输入数据中最大值为K，那么建立一个长度为K的数组C。在计数排序中，该数组的下标对应读入的正整数值（以及0），下标处的值表示小于等于该下标值的元素个数。

算法按照以下流程构建：

1. 初始化C为全0

2. 循环地读入一个整数，直接将索引C中该整数对应的下标处的值，将该值+1，表示该整数出现的次数增加1。直到读完n个整数。

3. 从下标1遍历到下标K，做 C[i] = C[i-1] + C[i] ， 处理完成后，就表示对每个下标index，C[index]表示小于等于index的整数数量。-> 这也就是说，如果这个index值是输入的整数，那么其在排序完成后的结果中，应该处于C[index]的位置（如果有重复，那么就是应该处于C[index-1]+1 ~ C[index]间）

4. 建立结果数组。

5. 依次从后往前读整数，直接将该整数作为索引index,找到C[index]的值，将该整数（index）放在输出结果序列中的C[index]处。同时，将C[index]减一，表示下次再遇到该值时，应该往前放一位。由于从后往前，且相等的数也是从后往前依次放的，所以其是稳定的(stable)。

6. 返回结果数组

###基数排序(radix sort)

最早应用于老式穿卡机上的算法。

从低位往高位走，每次按照一个位次(或者固定位次)上数字的大小进行`稳定排序`,当最高位排序完成后，整个变得有序。

1. 为何从低往高，而不是从高往低：可以在纸上写一下，如果从高位往低位，那么必须采用递归而非迭代的方式——即高位排在前面的数，则在后面的排序中必须一直排在前面；如果不递归，那么必然排序就错了。而从低位往高位，每次排序高位大的必然排在前面，正确；同时由于是稳定排序，在高位相等的情况下，前面位次排序的相对顺序保证了其也是正确的！

2. 位次的选择：以10进制为例，直观地，每次排序一位。如果子程序使用计数排序，那么需要迭代 `ceil(lg MAX)` 次，每次时间复杂度为O(n+10); 如果选择2位，那么迭代次数显然减半，而每次的复杂度并不会明显提升1倍，所以合适的位次应该是也影响了具体的速度。不严谨地，设每次选择K位，那么需要迭代次数为`ceil(lg_{10^K} n)`，每次时间复杂度认为是O(n)，那么在一定范围内，提高位次能够提高速度。

> 题目中，有一个如何在O(n)时间内排序范围为0 ~ n^2 - 1 的n个数？没有思路。

###桶排序

对n个浮点数，开n个桶，每个桶又都是链表（类似外链式HashTable的结构）。对每个浮点数，乘上n，向下取整，得到其应该落到哪个桶中，然后将该数插入到该桶中。插入时使用插入排序，使得每个桶内大小有序。

最后，一次从0到n-1，合并每个桶的结果。因为局部有序，且每个桶间的数大小有序，故最终合并后有序。

有点像快排，因为首先元素的大致位置在分散到桶的时刻就确定了，正如快排中每个元素被主元所分割，确定相对顺序。

最后合并又似乎有些像归并，不过细想，还是更像快排一些。包括合并过程——快排没有合并，但是这里其实也只是连接，没有互相比较的过程。

比较神奇的是，如果数据分布满足一定的规律：`只要输入满足这样一个性质，即各个桶的尺寸的平方和与总的元素数呈线性关系`，那么桶排序可以以线性时间运行。

这是通过算n个桶的期望排序时间来确定的——每个桶的排序时间显然是O(k^2)的，k是一个桶中元素个数。但是计算其期望时，可以得到其关于n是常数，具体地，为`2 - 1/n` , 因而总的n个桶，排序时间是线性的。有些神奇。
