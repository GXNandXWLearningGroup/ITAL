/************************************************
"You loved by me and the whole world~ "
Program    : 
Description: note about countting sort 
Author     : Anan - gxnhit@gmail.com
Date       : 2016-03-24 17:18:36
Last modified: 2016-03-24 17:18:36
**************************************************/
*计数排序：
**算法思想：
**只针对整数数据而且数据范围已知的数据集合适用。
**需要申请一个数据范围大小的数组A来记录当前数据集合的数值分布情况。
**A[j]表示数据集合中等于ｊ的元素的个数。
**
**首先,初始化A[]全部为0;
**然后,更新A[]使得A[j]＝数据集合中<=j的数的个数 即A[j]+=A[j-1]。
**最后,更新根据A[]和原始数据集将排序的数写入到新的数组B中，
**
**简而言之，统计原始数据集合中每个数值有几个大于等于自身，将统计结果放在一个数组A中,由于A比较特殊A的下标表示的就是原始集合的数值，所以可以根据此来得到排序结果。
**
***算法复杂度：O(n);

*基数排序:
***基数排序的基本思想，最重要的是要采用一种稳定的排序算法（即排序之后相同元素的位置相对不变，原来在前边的仍然在前边...）
**算法复杂度为:θ(d(n+k)) 其中d为数据集的最大位数， n为数据集合中数据的个数 k位每一位的可能取指情况。
**
**桶排序:
**以数据范围在[0,1]之内的数据集合进行排序为例来说明。桶排序类似于基数排序不同之处在于基数排序相当于桶的个数等于待排序集合的数的个数每个桶中不能放多于两个，并多次采用稳定的排序策略来完成排序。桶排序是将数据只按照一位(最高位进行排序)排序完成之后，分配后每个桶中的元素个数可能不止一个,然后将每个桶中的数据进行有序化，此时可以采用任何排序算法对桶内的各组数据进行排序。
**时间复杂度：　θ(n)+Σ(pow(n',2)) (n'为每个桶中元素的个数) 可以证明当数据服从均匀分布时候桶排序的时间复杂度是θ(n);
**
*** 列排序
***** 列排序是一种神奇的排序，它用于排序矩阵，可以将无序的矩阵排列成为按照从左到右，从上到下递减的次序排列好。
总共分为８个步： r行　s列  r必须是偶数，s必须是r的因子，且r>=2*s*s。
------ 奇数步都是列排序。
----->1:列排序
----->2:对矩阵进行转置,列转到行,。
----->3:列排序
----->4:对矩阵进行转置和第二个互逆,行转到列。
----->5:列排序
----->6:对于按照列整体下移半列,这样会导致最后一列剩余半列位空，对就是这样的。
----->7:列排序
----->8:做第6步的逆操作。就得到了排序结果。好神奇！！　如何证明暂时没有完全懂。

